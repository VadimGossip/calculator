## Распределенный вычислитель арифметических выражений
### [Ссылка на telegram автора](https://t.me/iyozy)

## Описание
Комплекс сервисов илюстрирующих распределенную модель вычислений и основным паттерны, которые могут быть использованы
для ее реализации.

## В основе лежат следующиет требования
Пользователь хочет считать арифметические выражения.
Он вводит строку 2 + 2 * 2 и хочет получить в ответ 6. Но наши операции сложения и умножения (также деления и вычитания) выполняются "очень-очень" долго.
Поэтому вариант, при котором пользователь делает http-запрос и получает в качетсве ответа результат, невозможна.
Более того: вычисление каждой такой операции в нашей "альтернативной реальности" занимает "гигантские" вычислительные мощности.
Соответственно, каждое действие мы должны уметь выполнять отдельно и масштабировать эту систему можем добавлением вычислительных мощностей в нашу систему в виде новых "машин".
Поэтому пользователь, присылая выражение, получает в ответ идентификатор выражения и может с какой-то периодичностью уточнять у сервера "не посчиталость ли выражение"?
Если выражение наконец будет вычислено - то он получит результат. Помните, что некоторые части арфиметического выражения можно вычислять параллельно.

## Разворачивание
Для запуска требуется выполнить сначала команду
```
docker compose up -d
```
Потом создать структуру таблиц с помощью скрипта миграции
Потребуется инструмент migrate [source](https://github.com/golang-migrate/migrate)
```
migrate -path ./schema -database "postgres://postgres:postgres@localhost:5432/calculator_db?sslmode=disable" up
```
Для удаления таблиц
```
migrate -path ./schema -database "postgres://postgres:postgres@localhost:5432/calculator_db?sslmode=disable" down
```

## Особенности реализации
В docker compose описано создание системы из 5 контейнеров. 
1) calculator-api. http сервер, принимает запросы от клиента с заданиями и от агентов вычислителей с посчитанными заданиями и heartbeat
2) message-broker. Брокер сообщений RabbitMQ, используется для передачи сообщений агентам-вычислителям.
3) calculator_db. База данных на Postgres. В нее вносится информация о посчитанных выражениях, подвыражениях, которые находятся в процессе рассчета,
пользовательские настройки длительностей операций и региструются heartbeat агентов вычислителей.
4) calculator-agentN. Агент вычислитель, достает подвыражение из очереди и передает рабочему внутри сервиса на вычисление, количество одновременно допустимых
рабочих регулируется переменной среды. В данном примере поднимаются 2 агента.

## Использование
Сервис api принимает следующие запросы.
1) Запрос на постановку выражения на вычисление.
```
curl --location --request POST 'http://localhost:8080/expression' --header 'Content-Type: application/json' --data '{
    "req_uid": "2",
    "expression": "1/1/2.2/3.3"
}'
```
Допустимы выражения, хотя бы с одним знаком операции, не более 50 символов в длину(регулируется параметром в конфиге), состоящие из
чисел(целые и с плавающей точкой) и знаков операций `+-/*`. Скобки, двойные знаки операций(-*, +-, -+ и так далее) недопустимы, планирую добавить позднее.
req_uid - Это уникальный идентификатор запроса, нужен для того, чтобы если пользователь не получил ответ содержащий созданное для расчета выражение, он мог
повторным запросом его найти. Если под данным uid уже существует выражение, то сервис просто вернет его пользователю
2) Запрос на отображение всех выражений
```
curl --location --request GET 'http://localhost:8080/expression'
```
Выражения могут быть в процессе расчета, рассчитаны с ошибкой(деление на 0), расчитаны без ошибки.
3) Запрос на добавление замедления для той или иной математической операции. Так как мы имитируем нагрузку на вычислителях. Каждую из четырех допустимых
математических операций можно замедлить. Замедление передается в ms. Допустимы значения от 0 до 65535
Если длительность уже зарегистрированна, ее значение будет перезаписано на новое переданное в запросе. По умолчанию замедление 0.
```
curl --location --request POST 'http://localhost:8080/duration' --header 'Content-Type: application/json' --data '{
    "+":5000,
    "-":5000,
    "*":1000,
    "/":10000
}'
```
4) Запрос на возвращение всех Агентов. Возращает список зарегистрированных агентов-вычислителей, с их именем, датой создания и heartbeat.
```
curl --location --request GET 'http://localhost:8080/agent'
```

## Переменные окружения
### calculator-api
Параметры подключения к базе
```
  DB_HOST=postgres
  DB_PORT=5432
  DB_USERNAME=postgres
  DB_NAME=calculator_db
  DB_SSLMODE=disable
  DB_PASSWORD=postgres
```
### agent
Имя агента и количество парралельных вычислений, которые он может делать
```
  AGENT_NAME=AGENT_1
  AGENT_MAX_PROCESSES=5
```
### calculator_db
```
  POSTGRES_PASSWORD=postgres
  POSTGRES_USER=postgres
  POSTGRES_DB=calculator_db
```

### Особенности организации очереди
В брокере мы создаем 2 очереди, одна для работы, другая для сообщений, которые не получили подтверждения обработки после вычитывания.
Подразумевается следующий сценарий, хотя для данного проекта он выглядит избыточным, так как данная исключительная ситуация покрывается другим сценарием
самовосттановления. Агент вычитал задачу из очереди, обработал ее и пытаясь сохранить ответ получил ошибку. В этом случае он ставит сообщению в очереди Nack,
что приводит к тому, что сообщение попадает в очередь исключений на 20 секунд(параметр задается в конфиге), а затем возвращается в основную очередь. Где может
быть взят любым свободным вычислителем, вычисление будет проведено заново и будет завново предпринята попытка сообщить результат calculator-api. 

### Схема взаимодействия сервисов
![Схема взаимодействия сервисов](schema.png "Схема взаимодействия сервисов")

### Описание основных сценариев
1) Положительный. Клиент передает выражение. Api разбивает выражение на подвыражения сохраняет в БД. Отправляет подвыражения, которые могут быть посчитаны
независимо в очередь, оттуда они вычитываются агентами, агент отправляет на api информацию о то, что он взял подвыржение в работу. Агенты 
вместе с подвыражениями получают информацию, о том насколько нужно замедлиться. После выполнения вычисления агенты отправляют на api результаты. Если было
подсчитано последнее повыражение выражения, оно меняет статус на подсчитанное и забирает результат последнего подвыражения.
2) Агент не смог сообщить api, что он хочет взять выражение. Выражение возращается в очередь, попадает в очередь исключений и через 20 секунд его снова может
взять какой-то агент. Дополнительно существет процесс на api, который мониторит не взятые выражения раз в N минут(определяется конфигом), поставит подвыражение еще раз.
В этом случае мы получаем дубль в очереди, но такая избыточность, не страшна, как только выражение возьмет, хоть кто-то, следующие попытки взятия буду сразу
отбрасываться вычислителями, еще до начала вычислений.
3) Агент не смог сообщить, что закончил, сообщение вернется в очередь через очередь исключений через 20 сек. Процесс на api, который мониторит не взятые выражения раз в N минут
заодно проверяет зависшие сообщения, он скинет им флаг агента и они как свободные будут перепоставлены в очередь.
4) Агент умер. Процесс, который мониторит heartbeat от агентов, проверка раз в N(конфиг), разрешено молчать M(конфиг), признает агента мертвым и сбросит его
со всех задач в процессе рассчета. Далее процесс из пункта 2, заметит эти задачи и перепоставит в очередь, где их заберут свободные агенты.
5) Api умерло. Запросы от клиента не принимаются. Сразу после старта через N(конфиг) процесс из пункта 2 перепоставит подвыражения.
6) Умерла база. Клиент не может зарегистировать новые задачи.

### Что еще хотелось бы сделать
1. Тесты. Тесты. Тесты. Тесты.
2. Встроить migrate в образы. Добавить замедлители для старта зависимых сервисов.
3. Вынести в отдельный сервис общение с базой. И уже общаться с ним (grpc) агентами и api.
4. Удалять из таблицы с подвыражениями, подвыражения, для посчитанных выражений. Они уже ни к чему, только пухнущая таблица, скорее как логи на первом этапе.

